
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Post-processing &#8212; TLViz 0.1.5 documentation</title> 
<link rel="stylesheet" href="../_static/tensorly_style.css">
<link rel="apple-touch-icon" sizes="180x180" href="../_static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../_static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../_static/favicon/favicon-16x16.png">
<link rel="manifest" href="../_static/favicon/site.webmanifest">
<link rel="mask-icon" href="../_static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="../_static/favicon/favicon.ico">
<meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tensorly_style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />

  
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 <script src="../_static/navbar_burger.js"></script>
 <script defer src="https://use.fontawesome.com/releases/v5.14.0/js/all.js"></script>
 
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Factor tools" href="factor_tools.html" />
    <link rel="prev" title="API Reference" href="../api.html" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  </head>
<body  class="has-navbar-fixed-top">

  <header>
    <navbar>
      <nav class="navbar top-navbar is-fixed-top has-shadow is-flex-wrap-wrap" role="navigation" aria-label="main top navigation">
        <div class="navbar-brand">
        <!-- Always displayed, last item has to be navbar-burger -->

          <a class="navbar-item" href="../index.html">
            <img src="../_static/tlviz_logo.svg" height="28">
          </a>

          <!-- <a class="navbar-item is-hidden-desktop" href="../index.html">
            <span class="icon"><i class="fa fa-home" aria-hidden="true"></i></span>
          </a> -->
          <a class="navbar-item is-hidden-desktop" href="https://github.com/tensorly/viz" target="_blank">
              <span class="icon"><i class="fab fa-github"></i></span>
          </a>

          <a role="button" class="navbar-burger" data-target="top-nav-menu" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
          </a>

        </div>
        
        <div class="navbar-menu" id="top-nav-menu">
        <!-- only on larger displays (> 1024px) -->

          <div class="navbar-start">
          <!-- RIGHT -->
            <a class="navbar-item" href="../about_tensors.html">
              Introduction
            </a>
            <a class="navbar-item" href="../installation.html">
              Installation
            </a>
            <a class="navbar-item" href="../auto_examples/index.html">
              Examples
            </a>
            <a class="navbar-item" href="../api.html">
              API
            </a>
            <a class="navbar-item" href="https://tensorly.org" target="_blank">
              TensorLy
            </a>

          </div>
        
          <div class="navbar-end">
            <div class="navbar-item">
            <!-- LEFT -->

            <!-- <a class="navbar-item is-hidden-touch" href="../index.html">
              <span class="icon-text">
                <span class="icon">
                  <i class="fa fa-home"></i>
                </span>
                <span>Home</span>
              </span>
              <span class="icon"><i class="fa fa-home" aria-hidden="true"></i></span>
            </a> -->
            <a class="button is-hidden-touch is-dark" href="https://github.com/tensorly/viz" target="_blank">
              <span class="icon-text">
                <span class="icon is-large">
                  <i class="fab fa-github"></i>
                </span>
                <span>Github</span>
              </span>
                <!-- <span class="icon"><i class="fab fa-github"></i></span> -->
            </a>

            </div> <!-- navbar item -->
          </div> <!-- navbar end -->
        </div> <!-- only large items -->

      </nav>
      
    </navbar>
  </header>

  <div id="column-container">
  <div class="columns is-mobile is-centered">
	
      <div class="column is-10-mobile is-one-third-tablet is-3-desktop is-hidden-mobile" id="sidebar">
    <!-- Side menu  -->
    <aside class="sticky-nav sidebar-menu">
<div class="sidebar-search">
  <form class="field" id="searchbox" role="search" action="../search.html" method="get">
    <!-- <label class="label" id="searchlabel">Quick search</label> -->
    <div class="field has-addons">
      <div class="control is-expanded">
        <input class="input" type="text" placeholder="Search in TLViz" name="q" aria-labelledby="searchlabel">
      </div>
      <div class="control">
        <input class="button is-info" type="submit" value="Go" />
      </div>
    </div>
  </form>
  <script>$('#searchbox').show(0);</script>
  <script>
  $(document).ready(function() {
    Document.highlightSearchWords = function() {
      var params = $.getQueryParameters();
      var terms = (params.highlight) ? params.highlight[0].split(/\s+/) : [];
      if (terms.length) {
        var body = $('div.body');
        if (!body.length) {
          body = $('body');
        }
        window.setTimeout(function() {
          $.each(terms, function() {
            body.highlightText(this.toLowerCase(), 'highlighted');
          });
        }, 10);
        $('<p class="highlight-link"><a href="javascript:Documentation.' +
          'hideSearchWords()">' + _('Hide All')
          + '<span class="tag is-delete"></span>'
          + '</a></p>')
            .appendTo($('#searchbox'));
      }
    };
  });
  </script>
</div>
      
      <div class="sidebar-menu-toc">
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about_tensors.html">What are tensors and tensor decompositions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Gallery of examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Post-processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="factor_tools.html">Factor tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="model_evaluation.html">Model evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="multimodel_evaluation.html">Multi-model evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="outliers.html">Outlier detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualisation.html">Visualisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">Example datasets</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tensorly_backends.html">Working with TensorLy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribution guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>
 
      </div>
    </aside>
  </div>
  

    <div class="column main-column">

      <!-- Main content  -->
      <section class="main-section">

        <!-- Toggle menu button -->
		
        <div class="side-menu-toggle">
          <button class="button" id="toggle-sidebar" onclick="toggle_sidebar()">
            <span class="icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
            <span>menu</span> 
          </button>
        </div>
        

        <div class="content main-content">
          
  <section id="module-tlviz.postprocessing">
<span id="post-processing"></span><h1>Post-processing<a class="headerlink" href="#module-tlviz.postprocessing" title="Permalink to this heading">¶</a></h1>
<p><strong>Functions:</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tlviz.postprocessing.add_factor_metadata" title="tlviz.postprocessing.add_factor_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_factor_metadata</span></code></a>(cp_tensor, dataset)</p></td>
<td><p>Adds the additional coordinates along each dataset dimension as new columns in the factor matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tlviz.postprocessing.factor_matrix_to_tidy" title="tlviz.postprocessing.factor_matrix_to_tidy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factor_matrix_to_tidy</span></code></a>(factor_matrix[, ...])</p></td>
<td><p>Convert a factor matrix into a tidy dataset, for use with Plotly Express.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tlviz.postprocessing.label_cp_tensor" title="tlviz.postprocessing.label_cp_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_cp_tensor</span></code></a>(cp_tensor, dataset)</p></td>
<td><p>Label the CP tensor by converting the factor matrices into DataFrames with a sensible index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tlviz.postprocessing.postprocess" title="tlviz.postprocessing.postprocess"><code class="xref py py-obj docutils literal notranslate"><span class="pre">postprocess</span></code></a>(cp_tensor[, dataset, ...])</p></td>
<td><p>Standard postprocessing of a CP decomposition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tlviz.postprocessing.resolve_cp_sign_indeterminacy" title="tlviz.postprocessing.resolve_cp_sign_indeterminacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resolve_cp_sign_indeterminacy</span></code></a>(cp_tensor, dataset)</p></td>
<td><p>Resolve the sign indeterminacy of CP models.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="tlviz.postprocessing.add_factor_metadata">
<span class="sig-prename descclassname"><span class="pre">tlviz.postprocessing.</span></span><span class="sig-name descname"><span class="pre">add_factor_metadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tlviz/_xarray_wrapper.html#add_factor_metadata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tlviz.postprocessing.add_factor_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the additional coordinates along each dataset dimension as new columns in the factor matrices.</p>
<p>The coordinates of xarray DataArrays can contain metadata. For each dimension, there may be additional
coordinates that are not used for indexing purposes. This function will iterate over all modes of
a dataset and a labelled CP tensor and add the additional coordinates as new columns in the factor
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cp_tensor</strong><span class="classifier">labelled CP Tensor</span></dt><dd></dd>
<dt><strong>dataset</strong><span class="classifier">xarray.DataArray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>CP-tensor like tuple where the factor matrices are augmented with additional metadata.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tlviz.data</span> <span class="kn">import</span> <span class="n">load_oslo_city_bike</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tlviz.postprocessing</span> <span class="kn">import</span> <span class="n">postprocess</span><span class="p">,</span> <span class="n">add_factor_metadata</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tensorly.decomposition</span> <span class="kn">import</span> <span class="n">parafac</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bikes</span> <span class="o">=</span> <span class="n">load_oslo_city_bike</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bikes</span><span class="o">.</span><span class="n">coords</span>
<span class="go">Coordinates:</span>
<span class="go">  * End station name  (End station name) object &#39;7 Juni Plassen&#39; ... &#39;Økernve...</span>
<span class="go">    lat               (End station name) float64 59.92 59.93 ... 59.93 59.92</span>
<span class="go">    lon               (End station name) float64 10.73 10.75 ... 10.8 10.78</span>
<span class="go">  * Hour              (Hour) int32 0 1 2 3 4 5 6 7 8 ... 16 17 18 19 20 21 22 23</span>
<span class="go">  * Month             (Month) int32 1 2 3 4 5 6 7 8 9 10 11 12</span>
<span class="go">  * Day of week       (Day of week) int32 0 1 2 3 4 5 6</span>
<span class="go">  * Year              (Year) int32 2020 2021</span>
</pre></div>
</div>
<p>We see that the <code class="docutils literal notranslate"><span class="pre">End</span> <span class="pre">station</span> <span class="pre">name</span></code> dimension has two additional columns: <code class="docutils literal notranslate"><span class="pre">lat</span></code> and <code class="docutils literal notranslate"><span class="pre">lon</span></code>.
These contain metadata about the end station coordinates, and it can be useful to have these
columns also in the factor matrices. To do this, we first fit a PARAFAC model to the dataset,
then we postprocess it to label the CP tensor and finally, we add the metadata information</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parafac</span><span class="p">(</span><span class="n">bikes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp_labelled</span> <span class="o">=</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">bikes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cp_labelled</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
<span class="go">RangeIndex(start=0, stop=3, step=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp_with_metadata</span> <span class="o">=</span> <span class="n">add_factor_metadata</span><span class="p">(</span><span class="n">cp_labelled</span><span class="p">,</span> <span class="n">bikes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cp_with_metadata</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
<span class="go">Index([0, 1, 2, &#39;lat&#39;, &#39;lon&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<p>We see that when we add the metadata, then the latitude and longitude columns are added
to the dataframe.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tlviz.postprocessing.factor_matrix_to_tidy">
<span class="sig-prename descclassname"><span class="pre">tlviz.postprocessing.</span></span><span class="sig-name descname"><span class="pre">factor_matrix_to_tidy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Component'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Signal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tlviz/postprocessing.html#factor_matrix_to_tidy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tlviz.postprocessing.factor_matrix_to_tidy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a factor matrix into a tidy dataset, for use with Plotly Express.</p>
<p>If we convert a factor matrix into a tidy dataset (or long table), then we get a table on the form</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">Tidy format factor matrix</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 33.3%" />
<col style="width: 33.3%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>Component</p></th>
<th class="head"><p>Signal</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0.1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0.5</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>38</p></td>
<td><p>2</p></td>
<td><p>0.7</p></td>
</tr>
<tr class="row-even"><td><p>39</p></td>
<td><p>2</p></td>
<td><p>0.2</p></td>
</tr>
</tbody>
</table>
<p>The component vectors are all stacked on top of each other, with a separate column that specifies which
component each row belongs to. This function can also preserve metadata, which is signified by columns
that have non-integer column names. For example, if we have a dataframe on the form</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">Factor matrix with metadata</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>lat</p></th>
<th class="head"><p>lon</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0.1</p></td>
<td><p>0.2</p></td>
<td><p>0.5</p></td>
<td><p>59.91273</p></td>
<td><p>10.74609</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0.5</p></td>
<td><p>0.2</p></td>
<td><p>0.1</p></td>
<td><p>63.43049</p></td>
<td><p>10.39506</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>0.2</p></td>
<td><p>0.1</p></td>
<td><p>0.3</p></td>
<td><p>60.39299</p></td>
<td><p>5.32415</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>0.0</p></td>
<td><p>0.2</p></td>
<td><p>0.1</p></td>
<td><p>58.97005</p></td>
<td><p>5.73332</p></td>
</tr>
</tbody>
</table>
<p>and convert it into a tidy format factor matrix, then we get a table on the form</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">Tidy format factor matrix with metadata</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Index</p></th>
<th class="head"><p>lat</p></th>
<th class="head"><p>lon</p></th>
<th class="head"><p>Component</p></th>
<th class="head"><p>Signal</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>59.91273</p></td>
<td><p>10.74609</p></td>
<td><p>0</p></td>
<td><p>0.1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>63.43049</p></td>
<td><p>10.39506</p></td>
<td><p>0</p></td>
<td><p>0.5</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>69.6489</p></td>
<td><p>18.95508</p></td>
<td><p>2</p></td>
<td><p>0.0</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>58.97005</p></td>
<td><p>5.73332</p></td>
<td><p>2</p></td>
<td><p>0.1</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>factor_matrix</strong><span class="classifier">pd.DataFrame</span></dt><dd><p>A labelled factor matrix potentially with metadata columns</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">str</span></dt><dd><p>Name of the column that specifies which component each row belongs to</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name of the column that holds the magnitude of each component entry</p>
</dd>
<dt><strong>id_vars</strong><span class="classifier">iterable or None (default=None)</span></dt><dd><p>Which columns to interpret as metadata. The columns not specified here are considered as the components.
If <code class="docutils literal notranslate"><span class="pre">id_vars</span> <span class="pre">is</span> <span class="pre">None</span></code>, then all columns with non-integer names are considered metadata columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>pd.DataFrame</dt><dd><p>Tidy format factor matrix</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tlviz.postprocessing</span> <span class="kn">import</span> <span class="n">factor_matrix_to_tidy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_matrix</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">          0         1         2</span>
<span class="go">0  0.636962  0.269787  0.040974</span>
<span class="go">1  0.016528  0.813270  0.912756</span>
<span class="go">2  0.606636  0.729497  0.543625</span>
<span class="go">3  0.935072  0.815854  0.002739</span>
<span class="go">4  0.857404  0.033586  0.729655</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tidy_factor_matrix</span> <span class="o">=</span> <span class="n">factor_matrix_to_tidy</span><span class="p">(</span><span class="n">factor_matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tidy_factor_matrix</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">   index Component    Signal</span>
<span class="go">0      0         0  0.636962</span>
<span class="go">1      1         0  0.016528</span>
<span class="go">2      2         0  0.606636</span>
<span class="go">3      3         0  0.935072</span>
<span class="go">4      4         0  0.857404</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_matrix_with_metadata</span> <span class="o">=</span> <span class="n">factor_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_matrix_with_metadata</span><span class="p">[</span><span class="s2">&quot;Metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor_matrix_with_metadata</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">          0         1         2  Metadata</span>
<span class="go">0  0.636962  0.269787  0.040974  0.688447</span>
<span class="go">1  0.016528  0.813270  0.912756  0.388921</span>
<span class="go">2  0.606636  0.729497  0.543625  0.135097</span>
<span class="go">3  0.935072  0.815854  0.002739  0.721488</span>
<span class="go">4  0.857404  0.033586  0.729655  0.525354</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tidy_factor_matrix_with_metadata</span> <span class="o">=</span> <span class="n">factor_matrix_to_tidy</span><span class="p">(</span><span class="n">factor_matrix_with_metadata</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tidy_factor_matrix_with_metadata</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">   Metadata  index Component    Signal</span>
<span class="go">0  0.688447      0         0  0.636962</span>
<span class="go">1  0.388921      1         0  0.016528</span>
<span class="go">2  0.135097      2         0  0.606636</span>
<span class="go">3  0.721488      3         0  0.935072</span>
<span class="go">4  0.525354      4         0  0.857404</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tlviz.postprocessing.label_cp_tensor">
<span class="sig-prename descclassname"><span class="pre">tlviz.postprocessing.</span></span><span class="sig-name descname"><span class="pre">label_cp_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tlviz/_xarray_wrapper.html#label_cp_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tlviz.postprocessing.label_cp_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the CP tensor by converting the factor matrices into DataFrames with a sensible index.</p>
<p>Convert the factor matrices into Pandas DataFrames where the DataFrame indices
are given by the coordinate names of an xarray DataArray. If the dataset has only
two modes, then it can also be a pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cp_tensor</strong><span class="classifier">CPTensor</span></dt><dd><p>CP Tensor whose factor matrices should be labelled</p>
</dd>
<dt><strong>dataset</strong><span class="classifier">xarray.DataArray of pandas.DataFrame</span></dt><dd><p>Dataset used to label the factor matrices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>CPTensor</dt><dd><p>Tuple on the CPTensor format, except that the factor matrices are DataFrames.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tlviz.postprocessing.postprocess">
<span class="sig-prename descclassname"><span class="pre">tlviz.postprocessing.</span></span><span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_cp_tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolve_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unresolved_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'transpose'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_behaviour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'normalise'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_smaller_rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_metadata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tlviz/postprocessing.html#postprocess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tlviz.postprocessing.postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard postprocessing of a CP decomposition.</p>
<p>This function will perform standard postprocessing of a CP decomposition.
If a reference CP tensor is provided, then the columns of <code class="docutils literal notranslate"><span class="pre">cp_tensor</span></code>’s
factor matrices are aligned with the columns of <code class="docutils literal notranslate"><span class="pre">reference_cp_tensor</span></code>’s
factor matrices.</p>
<p>Next, the factor matrices of the CP tensor are scaled according the the specified
weight behaviour (default is normalised).</p>
<p>If a dataset is provided, then the sign indeterminacy is resolved and if the
dataset is labelled (i.e. is an xarray or a dataframe), then the factor matrices
of the CP tensor is labelled too.</p>
<p>This function is equivalent to calling</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">permute_cp_tensor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">distribute_weights</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">resolve_cp_sign_indeterminacy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">label_cp_tensor</span></code></p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>cp_tensor</strong><span class="classifier">CPTensor or tuple</span></dt><dd><p>CPTensor to postprocess</p>
</dd>
<dt><strong>dataset</strong><span class="classifier">ndarray or xarray (optional)</span></dt><dd><p>Dataset the CP tensor represents</p>
</dd>
<dt><strong>reference_cp_tensor</strong><span class="classifier">CPTensor or tuple (optional)</span></dt><dd><p>If provided, then the tensor whose factors we align the CP tensor’s
columns with.</p>
</dd>
<dt><strong>permute</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the factors are permuted in descending weight order if
<code class="docutils literal notranslate"><span class="pre">reference_cp_tensor</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>resolve_mode</strong><span class="classifier">int, iterable or None</span></dt><dd><p>Mode(s) whose factor matrix should be aligned with the data. If
None, then the sign should be corrected for all modes except the
<code class="docutils literal notranslate"><span class="pre">unresolved_mode</span></code>.</p>
</dd>
<dt><strong>unresolved_mode</strong><span class="classifier">int</span></dt><dd><p>Mode used to correct the sign indeterminacy in other mode(s). The
factor matrix in this mode may not be aligned with the data.</p>
</dd>
<dt><strong>method</strong><span class="classifier">“transpose” or “positive_coord”</span></dt><dd><p>Which method to use when computing the signs. Use <code class="docutils literal notranslate"><span class="pre">&quot;transpose&quot;</span></code>
for the method in <span id="id1">[<a class="reference internal" href="../references.html#id12" title="Rasmus Bro, Evrim Acar, and Tamara G Kolda. Resolving the sign ambiguity in the singular value decomposition. Journal of Chemometrics: A Journal of the Chemometrics Society, 22(2):135–140, 2008.">BAK08</a>, <a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span>, and
<code class="docutils literal notranslate"><span class="pre">&quot;positive_coord&quot;</span></code> for the method corrected for non-orthogonal
factor matrices described above.</p>
</dd>
<dt><strong>weight_behaviour</strong><span class="classifier">{“ignore”, “normalise”, “evenly”, “one_mode”} (default=”normalise”)</span></dt><dd><p>How to handle the component weights.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;ignore&quot;</span></code> - Do nothing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;normalise&quot;</span></code> - Normalise all factor matrices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;evenly&quot;</span></code> - All factor matrices have equal norm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;one_mode&quot;</span></code> - The weight is allocated in one mode, all other factor matrices have unit norm columns.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>weight_mode</strong><span class="classifier">int (optional)</span></dt><dd><p>Which mode to have the component weights in (only used if <code class="docutils literal notranslate"><span class="pre">weight_behaviour=&quot;one_mode&quot;</span></code>)</p>
</dd>
<dt><strong>allow_smaller_rank</strong><span class="classifier">bool (default=False)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then a low rank decomposition can be permuted against one with higher rank. The “missing columns”
are padded by nan values</p>
</dd>
<dt><strong>include_metadata</strong><span class="classifier">bool (default=True)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the factor metadata will be added as columns in the factor matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>CPTensor</dt><dd><p>The post processed CPTensor.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="factor_tools.html#tlviz.factor_tools.permute_cp_tensor" title="tlviz.factor_tools.permute_cp_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tlviz.factor_tools.permute_cp_tensor</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="factor_tools.html#tlviz.factor_tools.distribute_weights" title="tlviz.factor_tools.distribute_weights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tlviz.factor_tools.distribute_weights</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#tlviz.postprocessing.resolve_cp_sign_indeterminacy" title="tlviz.postprocessing.resolve_cp_sign_indeterminacy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tlviz.postprocessing.resolve_cp_sign_indeterminacy</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#tlviz.postprocessing.label_cp_tensor" title="tlviz.postprocessing.label_cp_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tlviz.postprocessing.label_cp_tensor</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Here is an example were we use postprocess on a decomposition of aminoacid data</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tlviz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tensorly.decomposition</span> <span class="kn">import</span> <span class="n">parafac</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">tlviz</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load_aminoacids</span><span class="p">()</span>
<span class="go">Loading Aminoacids dataset from:</span>
<span class="go">Bro, R, PARAFAC: Tutorial and applications, Chemometrics and Intelligent Laboratory Systems, 1997, 38, 149-171</span>
</pre></div>
</div>
<p>The dataset is an xarray DataArray and it contains relevant side information</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
<span class="go">&lt;class &#39;xarray.core.dataarray.DataArray&#39;&gt;</span>
</pre></div>
</div>
<p>We see that after postprocessing, the cp_tensor contains pandas DataFrames</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp_tensor</span> <span class="o">=</span> <span class="n">parafac</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp_tensor_postprocessed</span> <span class="o">=</span> <span class="n">tlviz</span><span class="o">.</span><span class="n">postprocessing</span><span class="o">.</span><span class="n">postprocess</span><span class="p">(</span><span class="n">cp_tensor</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cp_tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">&lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cp_tensor_postprocessed</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
</pre></div>
</div>
<p>We see that after postprocessing, the factor matrix has unit norm</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cp_tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[160.82985402 182.37338941 125.3689186 ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cp_tensor_postprocessed</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[1. 1. 1.]</span>
</pre></div>
</div>
<p>When we construct a dense tensor from a postprocessed cp_tensor it is constructed
as an xarray DataArray</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tlviz</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cp_to_tensor</span><span class="p">(</span><span class="n">cp_tensor</span><span class="p">)))</span>
<span class="go">&lt;class &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tlviz</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cp_to_tensor</span><span class="p">(</span><span class="n">cp_tensor_postprocessed</span><span class="p">)))</span>
<span class="go">&lt;class &#39;xarray.core.dataarray.DataArray&#39;&gt;</span>
</pre></div>
</div>
<p>The visualisation of the postprocessed cp_tensor shows that the scaling and sign indeterminacy
is taken care of and x-xaxis has correct labels and ticks</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">tlviz</span><span class="o">.</span><span class="n">visualisation</span><span class="o">.</span><span class="n">components_plot</span><span class="p">(</span><span class="n">cp_tensor</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../api/postprocessing-1.py">Source code</a>, <a class="reference external" href="../api/postprocessing-1_00_00.png">png</a>, <a class="reference external" href="../api/postprocessing-1_00_00.hires.png">hires.png</a>, <a class="reference external" href="../api/postprocessing-1_00_00.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="../_images/postprocessing-1_00_00.png" class="plot-directive" src="../_images/postprocessing-1_00_00.png" />
</figure>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">tlviz</span><span class="o">.</span><span class="n">visualisation</span><span class="o">.</span><span class="n">components_plot</span><span class="p">(</span><span class="n">cp_tensor_postprocessed</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../api/postprocessing-1_01_00.png">png</a>, <a class="reference external" href="../api/postprocessing-1_01_00.hires.png">hires.png</a>, <a class="reference external" href="../api/postprocessing-1_01_00.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="../_images/postprocessing-1_01_00.png" class="plot-directive" src="../_images/postprocessing-1_01_00.png" />
</figure>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tlviz.postprocessing.resolve_cp_sign_indeterminacy">
<span class="sig-prename descclassname"><span class="pre">tlviz.postprocessing.</span></span><span class="sig-name descname"><span class="pre">resolve_cp_sign_indeterminacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolve_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unresolved_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'transpose'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tlviz/postprocessing.html#resolve_cp_sign_indeterminacy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tlviz.postprocessing.resolve_cp_sign_indeterminacy" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the sign indeterminacy of CP models.</p>
<p>Tensor factorisations have a sign indeterminacy that allows any change in the
sign of the component vectors in one mode, under the condition that the sign
of a component vector in another mode changes as well. This means that we can
“flip” any component vector so long as the corresponding component vector in
another mode is also flipped. This flipping can hurt the model’s interpretability.
For example, if a factor represents a chemical spectrum, then this flipping may lead
to it being negative instead of positive.</p>
<p>To illustrate the sign indeterminacy, we start with the SVD, which is on the form</p>
<div class="math notranslate nohighlight">
\[\mathbf{X} = \mathbf{U} \mathbf{S} \mathbf{V}^\mathsf{T}.\]</div>
<p>The factorisation above is equivalent with the following factorisation:</p>
<div class="math notranslate nohighlight">
\[\mathbf{X} = (\mathbf{U} \text{diag}(\mathbf{f})) \mathbf{S} (\mathbf{V} \text{diag}(\mathbf{f}))^\mathsf{T},\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> is a vector containing only ones or negative ones. Similarly,
a CP factorisation with factor matrices <span class="math notranslate nohighlight">\(\mathbf{A}, \mathbf{B}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{C}\)</span>
is equivalent to the CP factorisations with the following factor matrices:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\((\mathbf{A} \text{diag}(\mathbf{f})), (\mathbf{B} \text{diag}(\mathbf{f}))\)</span> and <span class="math notranslate nohighlight">\(\mathbf{C}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((\mathbf{A} \text{diag}(\mathbf{f})), \mathbf{B}\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C} \text{diag}(\mathbf{f}))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{A}, (\mathbf{B} \text{diag}(\mathbf{f}))\)</span> and <span class="math notranslate nohighlight">\((\mathbf{C} \text{diag}(\mathbf{f}))\)</span></p></li>
</ul>
</div></blockquote>
<p>One way to circumvent the sign indeterminacy is by imposing non-negativity. However,
that is not always a reasonable choice (e.g. if the data also contains negative entries).
When we don’t want to impose non-negativity constraints, then we need some other way to
resolve the sign indeterminacy (which this function provides). The idea is easiest described
in the two-way (matrix) case.</p>
<p>Consider a data matrix, <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> whose columns represent samples and rows represent
measurements. Then, we want the measurement-mode component-vectors to be mostly aligned with
the data matrix. The components should describe what the data is, not what it is not.
For example, if the data is non-negative, then the measurement-mode component vectors should
be mostly non-negative. With the SVD, we can compute whether we should flip the <span class="math notranslate nohighlight">\(r\)</span>-th
column of <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> by computing</p>
<div class="math notranslate nohighlight">
\[f_r = \sum_{i=1^I} v_{ir}^2 \text{sign}{v_{ir}}\]</div>
<p>if <span class="math notranslate nohighlight">\(f_r\)</span> is negative, then we should flip the sign of the <span class="math notranslate nohighlight">\(r-th\)</span> column of
<span class="math notranslate nohighlight">\(\mathbf{U}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> <span id="id2">[<a class="reference internal" href="../references.html#id12" title="Rasmus Bro, Evrim Acar, and Tamara G Kolda. Resolving the sign ambiguity in the singular value decomposition. Journal of Chemometrics: A Journal of the Chemometrics Society, 22(2):135–140, 2008.">BAK08</a>]</span>.</p>
<p>The methodology above works well in practice, and is rooted in the fact that the
<span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> can be interpreted as the coordinates of the
<span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> in a vector space spanned by the columns of
<span class="math notranslate nohighlight">\(\mathbf{U}\)</span>. Then, the above equation will give us component vectors where the data
points is mainly located in the non-negative orthant.</p>
<p>The above interpretation is correct under the assumption: <span class="math notranslate nohighlight">\(\mathbf{U}^\mathsf{T}\mathbf{U} = \mathbf{I}\)</span>.
However, the heuristic still works well when this is not the case <span id="id3">[<a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span>.
Still, we also include a modification of the above scheme where the same interpretation
holds with non-orthogonal factors.</p>
<div class="math notranslate nohighlight">
\[f_r = \sum_{i=1}^I h_{ir}^2 \text{sign}(h_{ir}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{H} = \mathbf{U}(\mathbf{U}^\mathsf{T}\mathbf{U})^{-1} \mathbf{X}\)</span>.
That is the rows of <span class="math notranslate nohighlight">\(\mathbf{H}\)</span> represent the rows of <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> as
described by the column basis of <span class="math notranslate nohighlight">\(\mathbf{U}\)</span>.</p>
<p>In the multiway case, when <span class="math notranslate nohighlight">\(\mathcal{X}\)</span> is a tensor instead of a matrix, we can
apply the same logic <span id="id4">[<a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span>. If we have the factor matrices
<span class="math notranslate nohighlight">\(\mathbf{A}, \mathbf{B}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{C}\)</span>, then we flip the sign of any
factor matrix (e.g. <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>) by computing</p>
<div class="math notranslate nohighlight">
\[f_r^{(\mathbf{A})} = \sum_{i=1}^I {h_{ir}^{(\mathbf{A})}}^2 \text{sign}({h_{ir}^{(\mathbf{A})}}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{H}^{(\mathbf{A})} = \mathbf{A}^\mathsf{T} \mathbf{X}_{(0)}\)</span> or
<span class="math notranslate nohighlight">\(\mathbf{H}^{(\mathbf{A})} = \mathbf{A}(\mathbf{A}^\mathsf{T}\mathbf{A})^{-1} \mathbf{X}_{(0)}\)</span>,
depending on whether the scheme based on the SVD scheme <span id="id5">[<a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span> or the
corrected scheme. <span class="math notranslate nohighlight">\(\mathbf{X}_{(0)} \in \mathbb{R}^{I \times JK}\)</span> is the tensor,
<span class="math notranslate nohighlight">\(\mathcal{X}\)</span>, unfolded along the first mode. We can then correct the sign of
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span> by multiplying and one of the other factor matrices by
<span class="math notranslate nohighlight">\(\text{diag}(\mathbf{f}^{(\mathbf{A})})\)</span>. By using this procedure, we can align all
factor matrices except for one (the unresolved mode) with the “direction of the data”.</p>
<p>Note that this sign indeterminacy comes as a direct consequence of the scaling indeterminacy
of component models, since <span class="math notranslate nohighlight">\(\text{diag}(\mathbf{f})^{-1} = \text{diag}(\mathbf{f})\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cp_tensor</strong><span class="classifier">CPTensor or tuple</span></dt><dd><p>TensorLy-style CPTensor object or tuple with weights as first
argument and a tuple of components as second argument.</p>
</dd>
<dt><strong>resolve_mode</strong><span class="classifier">int, iterable or None</span></dt><dd><p>Mode(s) whose factor matrix should be aligned with the data. If
None, then the sign should be corrected for all modes except the
<code class="docutils literal notranslate"><span class="pre">unresolved_mode</span></code>.</p>
</dd>
<dt><strong>unresolved_mode</strong><span class="classifier">int</span></dt><dd><p>Mode used to correct the sign indeterminacy in other mode(s). The
factor matrix in this mode may not be aligned with the data.</p>
</dd>
<dt><strong>method</strong><span class="classifier">“transpose” or “positive_coord”</span></dt><dd><p>Which method to use when computing the signs. Use <code class="docutils literal notranslate"><span class="pre">&quot;transpose&quot;</span></code>
for the method in <span id="id6">[<a class="reference internal" href="../references.html#id12" title="Rasmus Bro, Evrim Acar, and Tamara G Kolda. Resolving the sign ambiguity in the singular value decomposition. Journal of Chemometrics: A Journal of the Chemometrics Society, 22(2):135–140, 2008.">BAK08</a>, <a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span>, and
<code class="docutils literal notranslate"><span class="pre">&quot;positive_coord&quot;</span></code> for the method corrected for non-orthogonal
factor matrices described above.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>CPTensor or tuple</dt><dd><p>The CP tensor after correcting the signs.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">unresolved_mode</span></code> is not between <code class="docutils literal notranslate"><span class="pre">-dataset.ndim</span></code> and <code class="docutils literal notranslate"><span class="pre">dataset.ndim-1</span></code>.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">unresolved_mode</span></code> is in <code class="docutils literal notranslate"><span class="pre">resolve_mode</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For more information, see <span id="id7">[<a class="reference internal" href="../references.html#id12" title="Rasmus Bro, Evrim Acar, and Tamara G Kolda. Resolving the sign ambiguity in the singular value decomposition. Journal of Chemometrics: A Journal of the Chemometrics Society, 22(2):135–140, 2008.">BAK08</a>, <a class="reference internal" href="../references.html#id13" title="Rasmus Bro, Riccardo Leardi, and Lea Giørtz Johnsen. Solving the sign indeterminacy for multiway models. Journal of Chemometrics, 27(3-4):70–75, 2013.">BLJ13</a>]</span></p>
</dd></dl>

</section>


        </div>

		
        <nav class="pagination" role="navigation" aria-label="pagination">
    
    <a class="button is-medium pagination-previous" href="../api.html" title="previous page" accesskey="p">
        <span class="icon">
            <i class="fa fa-arrow-circle-left"></i>
        </span>
        <span>API Reference</span>
    </a>
    
    
    <a class="button is-medium pagination-next" href="factor_tools.html" title="next page" accesskey="n">
        <span>Factor tools </span>
        <span class="icon">
            <i class="fa fa-arrow-circle-right"></i>
        </span>
    </a>
    
</nav>

        

      </section>

        <footer class="footer">
    <div class="content has-text-centered">
        <div class="block">
          &copy; Copyright 2021, Marie Roald &amp; Yngve Mardal Moe.<br/>
        </div>
      <div class="block">
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> and the <a href="tensorly.org"><strong>TensorLy</strong></a> theme by <a href="jeankossaifi.com">Jean Kossaifi</a>.
      </div>
    </div>
  </footer>

    </div>

	
    

    

  </div>
  </div>

  <!-- Include here scripts that need to be added after the page is loaded -->
  <script>
    function toggle_sidebar() {
        var element = document.getElementById("sidebar");
        var container = document.getElementById("column-container");
        var localtoccolumn = document.getElementById("localtoc-column");
        element.classList.toggle("hide-tablet");
        element.classList.toggle("is-hidden-mobile");
        container.classList.toggle("sidemenu-hidden");
        localtoccolumn.classList.toggle("is-one-fifth-widescreen");
        localtoccolumn.classList.toggle("is-2-desktop");
        localtoccolumn.classList.toggle("is-3-desktop");
    }
  </script> 



  </body>
</html>